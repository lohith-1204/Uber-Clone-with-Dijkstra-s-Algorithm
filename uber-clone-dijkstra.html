 <!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Uber Clone with Dijkstra's Algorithm</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap');
  body {
    margin: 0;
    font-family: 'Roboto', sans-serif;
    background: linear-gradient(135deg, #2a2d45, #4e54c8);
    color: #eef2f7;
    height: 100vh;
    display: flex;
    flex-direction: column;
  }
  header {
    background: #3b3f72;
    padding: 1rem 2rem;
    font-size: 1.5rem;
    font-weight: 700;
    text-align: center;
    letter-spacing: 1.5px;
    box-shadow: 0 4px 8px rgba(0,0,0,0.3);
  }
  #main {
    flex: 1;
    display: flex;
    flex-direction: row;
    overflow: hidden;
  }
  #graph-container {
    flex: 3;
    background: #1e213a;
    position: relative;
  }
  svg {
    width: 100%;
    height: 100%;
    display: block;
  }
  #control-panel {
    flex: 1;
    background: #292e5a;
    padding: 1.5rem 2rem;
    box-sizing: border-box;
    display: flex;
    flex-direction: column;
  }
  h2 {
    margin-top: 0;
    margin-bottom: 1rem;
    color: #aeb3ff;
  }
  label {
    font-weight: 700;
    margin-top: 1rem;
    display: block;
    margin-bottom: 0.5rem;
    color: #ccd0ff;
  }
  select, button {
    width: 100%;
    padding: 0.5rem 1rem;
    font-size: 1rem;
    border-radius: 6px;
    border: none;
    outline: none;
    font-family: 'Roboto', sans-serif;
    margin-bottom: 1rem;
    cursor: pointer;
  }
  select {
    background: #3b3f72;
    color: #eef2f7;
  }
  button {
    background: #4e54c8;
    color: white;
    font-weight: 700;
    transition: background-color 0.3s;
  }
  button:hover:enabled {
    background: #686ed6;
  }
  button:disabled {
    background: #999abe;
    cursor: not-allowed;
  }
  #info {
    flex: 1;
    background: #23255a;
    border-radius: 10px;
    padding: 1rem;
    color: #d6d8ff;
    overflow-y: auto;
    font-size: 0.9rem;
    white-space: pre-wrap;
    box-shadow: inset 0 0 8px #333a9b;
  }
  /* Node style */
  .node {
    fill: #9ea9ff;
    stroke: #4e54c8;
    stroke-width: 2px;
    transition: fill 0.3s, stroke-width 0.3s;
    cursor: pointer;
  }
  .node.highlighted {
    fill: #ffc94e;
    stroke: #ffaa00;
    stroke-width: 4px;
  }
  .node.start {
    fill: #4ebcff;
  }
  .node.end {
    fill: #ff5f5f;
  }
  /* Edge style */
  .edge {
    stroke: #7c82d6;
    stroke-width: 3px;
    transition: stroke 0.3s, stroke-width 0.3s;
  }
  .edge.highlighted {
    stroke: #ffaa00;
    stroke-width: 5px;
  }

</style>
</head>
<body>
<header>Uber Clone with Dijkstra's Algorithm Visualization</header>
<div id="main">
  <div id="graph-container">
    <svg id="graph" viewBox="0 0 800 600" xmlns="http://www.w3.org/2000/svg" aria-label="Graph visualization">
      <!-- Graph edges and nodes will be generated by JS -->
    </svg>
  </div>
  <div id="control-panel">
    <h2>Controls</h2>
    <label for="start-select">Select Start Location:</label>
    <select id="start-select" aria-label="Select start location"></select>

    <label for="end-select">Select Destination:</label>
    <select id="end-select" aria-label="Select destination"></select>

    <button id="start-btn" disabled>Find Shortest Route</button>

    <h2>Algorithm Steps & Info</h2>
    <div id="info" tabindex="0" role="log" aria-live="polite" aria-atomic="true">
      Select start and destination, then click "Find Shortest Route"
    </div>
  </div>
</div>
<script>
  // Data model for the graph - nodes with positions and edges with weights
  const nodes = [
    { id: 'A', x: 120, y: 80 },
    { id: 'B', x: 300, y: 120 },
    { id: 'C', x: 500, y: 80 },
    { id: 'D', x: 200, y: 300 },
    { id: 'E', x: 420, y: 270 },
    { id: 'F', x: 640, y: 180 },
    { id: 'G', x: 100, y: 480 },
    { id: 'H', x: 350, y: 450 },
    { id: 'I', x: 600, y: 440 },
    { id: 'J', x: 700, y: 350 }
  ];

  // Edges between nodes (bidirectional) with weights as distances
  const edges = [
    { from: 'A', to: 'B', weight: 190 },
    { from: 'A', to: 'D', weight: 230 },
    { from: 'B', to: 'C', weight: 200 },
    { from: 'B', to: 'D', weight: 190 },
    { from: 'C', to: 'F', weight: 190 },
    { from: 'D', to: 'E', weight: 240 },
    { from: 'D', to: 'G', weight: 220 },
    { from: 'E', to: 'F', weight: 230 },
    { from: 'E', to: 'H', weight: 210 },
    { from: 'F', to: 'J', weight: 200 },
    { from: 'G', to: 'H', weight: 260 },
    { from: 'H', to: 'I', weight: 270 },
    { from: 'I', to: 'J', weight: 150 },
  ];

  // Build adjacency list for graph
  const adjacencyList = {};

  function buildGraph() {
    adjacencyList.clear;
    nodes.forEach(node => {
      adjacencyList[node.id] = [];
    });
    edges.forEach(edge => {
      adjacencyList[edge.from].push({ node: edge.to, weight: edge.weight });
      adjacencyList[edge.to].push({ node: edge.from, weight: edge.weight });
    });
  }
  buildGraph();

  const svg = document.getElementById('graph');
  const startSelect = document.getElementById('start-select');
  const endSelect = document.getElementById('end-select');
  const startBtn = document.getElementById('start-btn');
  const infoDiv = document.getElementById('info');

  // Create SVG elements for edges and nodes
  const svgEdges = [];
  const svgNodes = {};

  function createSVGElements() {
    // Clear existing SVG elements
    while(svg.firstChild) {
      svg.removeChild(svg.firstChild);
    }
    // Draw edges - lines between nodes
    edges.forEach((edge, i) => {
      const fromNode = nodes.find(n => n.id === edge.from);
      const toNode = nodes.find(n => n.id === edge.to);
      const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
      line.setAttribute('x1', fromNode.x);
      line.setAttribute('y1', fromNode.y);
      line.setAttribute('x2', toNode.x);
      line.setAttribute('y2', toNode.y);
      line.setAttribute('class', 'edge');
      line.setAttribute('data-from', edge.from);
      line.setAttribute('data-to', edge.to);
      line.setAttribute('data-weight', edge.weight);
      line.style.cursor = 'default';
      svg.appendChild(line);

      // Add edge label (distance)
      const midX = (fromNode.x + toNode.x) / 2;
      const midY = (fromNode.y + toNode.y) / 2;
      const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
      text.setAttribute('x', midX);
      text.setAttribute('y', midY - 5);
      text.setAttribute('fill', '#c0c4ff');
      text.setAttribute('font-size', '12px');
      text.setAttribute('font-family', 'Roboto, sans-serif');
      text.setAttribute('text-anchor', 'middle');
      text.textContent = edge.weight + 'm';
      svg.appendChild(text);

      svgEdges.push(line);
    });

    // Draw nodes - circles and labels
    nodes.forEach(node => {
      const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
      circle.setAttribute('cx', node.x);
      circle.setAttribute('cy', node.y);
      circle.setAttribute('r', 15);
      circle.setAttribute('class', 'node');
      circle.setAttribute('tabindex', 0);
      circle.setAttribute('role', 'button');
      circle.setAttribute('aria-label', 'Location ' + node.id);
      svg.appendChild(circle);

      // Label in center of node
      const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
      label.setAttribute('x', node.x);
      label.setAttribute('y', node.y + 5);
      label.setAttribute('fill', '#232545');
      label.setAttribute('font-weight', '700');
      label.setAttribute('font-family', 'Roboto, sans-serif');
      label.setAttribute('font-size', '14px');
      label.setAttribute('text-anchor', 'middle');
      label.style.userSelect = 'none';
      label.textContent = node.id;
      svg.appendChild(label);

      svgNodes[node.id] = circle;
    });
  }

  // Fill dropdowns for start and end selection
  function populateSelects() {
    nodes.forEach(node => {
      const option1 = document.createElement('option');
      option1.value = node.id;
      option1.textContent = node.id;
      startSelect.appendChild(option1);

      const option2 = document.createElement('option');
      option2.value = node.id;
      option2.textContent = node.id;
      endSelect.appendChild(option2);
    });
  }

  // Enable the start button if start !== end
  function updateButtonState() {
    startBtn.disabled = (startSelect.value === '' || endSelect.value === '' || startSelect.value === endSelect.value);
  }

  // Variables to store algorithm state
  let distances = {};
  let previous = {};
  let visited = new Set();
  let pq = [];
  let currentStep = 0;
  let algorithmSteps = [];

  // Helper Priority Queue class for Dijkstra
  class PriorityQueue {
    constructor() {
      this.elements = [];
    }
    enqueue(item, priority) {
      this.elements.push({ item, priority });
      this.elements.sort((a,b) => a.priority - b.priority);
    }
    dequeue() {
      return this.elements.shift().item;
    }
    isEmpty() {
      return this.elements.length === 0;
    }
  }

  // Clear all highlights from nodes and edges
  function clearHighlights() {
    Object.values(svgNodes).forEach(n => {
      n.classList.remove('highlighted', 'start', 'end');
    });
    svgEdges.forEach(e => e.classList.remove('highlighted'));
  }

  // Highlight shortest path edges
  function highlightPath(path) {
    for (let i = 0; i < path.length - 1; i++) {
      const from = path[i];
      const to = path[i+1];
      // find edge by matching from-to or to-from because edges are bidirectional
      svgEdges.forEach(edge => {
        const f = edge.getAttribute('data-from');
        const t = edge.getAttribute('data-to');
        if ((f === from && t === to) || (f === to && t === from)) {
          edge.classList.add('highlighted');
        }
      });
    }
  }

  // Run Dijkstra's algorithm with steps recorded for visualization
  function runDijkstraGraph(start, end) {
    // Initialize
    distances = {};
    previous = {};
    visited = new Set();
    pq = new PriorityQueue();
    algorithmSteps = [];

    nodes.forEach(node => {
      distances[node.id] = Infinity;
      previous[node.id] = null;
    });
    distances[start] = 0;
    pq.enqueue(start, 0);

    // Save initial state
    algorithmSteps.push({
      distances: { ...distances },
      visited: new Set(visited),
      currentNode: null,
      pq: [...pq.elements],
      message: 'Initialization complete.'
    });

    while(!pq.isEmpty()) {
      const current = pq.dequeue();

      if (visited.has(current)) continue;

      visited.add(current);

      algorithmSteps.push({
        distances: { ...distances },
        visited: new Set(visited),
        currentNode: current,
        pq: [...pq.elements],
        message: 'Processing node ' + current
      });

      if (current === end) {
        algorithmSteps.push({
          distances: { ...distances },
          visited: new Set(visited),
          currentNode: current,
          pq: [...pq.elements],
          message: 'Destination reached.'
        });
        break;
      }

      const neighbors = adjacencyList[current];
      neighbors.forEach(neighbor => {
        if (!visited.has(neighbor.node)) {
          const alt = distances[current] + neighbor.weight;
          if (alt < distances[neighbor.node]) {
            distances[neighbor.node] = alt;
            previous[neighbor.node] = current;
            pq.enqueue(neighbor.node, alt);
            algorithmSteps.push({
              distances: { ...distances },
              visited: new Set(visited),
              currentNode: current,
              pq: [...pq.elements],
              message: `Updated distance for node ${neighbor.node} to ${alt} meters`
            });
          }
        }
      });
    }

    // Build path
    const path = [];
    let u = end;
    if (previous[u] !== null || u === start) {
      while (u !== null) {
        path.unshift(u);
        u = previous[u];
      }
    }

    return { path, distance: distances[end], steps: algorithmSteps };
  }

  // Visualize one step of the algorithm
  function visualizeStep(step) {
    clearHighlights();

    // Highlight visited nodes
    step.visited.forEach(id => {
      const nodeEl = svgNodes[id];
      if (nodeEl) {
        nodeEl.classList.add('highlighted');
      }
    });

    // Highlight current node bigger
    if (step.currentNode) {
      const currEl = svgNodes[step.currentNode];
      if (currEl) {
        currEl.classList.add('start');
      }
    }

    // Show distances as tooltips on nodes
    nodes.forEach(node => {
      const dist = step.distances[node.id];
      const title = dist === Infinity ? 'Distance: ∞' : 'Distance: ' + dist + ' m';
      svgNodes[node.id].setAttribute('title', title);
    });

    // Show priority queue nodes as well
    // Not graphically shown separately here, but can be included in info.

    // Update info text
    let pqContent = step.pq.map(e => e.item + '(' + e.priority + ')').join(', ');
    let visitedContent = Array.from(step.visited).sort().join(', ');
    infoDiv.textContent =
      'Step info:\n' +
      step.message + '\n\n' +
      'Current node: ' + (step.currentNode || 'None') + '\n' +
      'Visited nodes: ' + visitedContent + '\n' +
      'Priority Queue: ' + pqContent + '\n\n' +
      'Distances to nodes:\n' +
      Object.entries(step.distances)
        .map(([key,val]) => {
          const distLabel = val === Infinity ? '∞' : val;
          return `${key}: ${distLabel} m`;
        })
        .join('\n');
  }

  // Animate step by step visualization
  async function animateAlgorithm(steps, path, distance) {
    startBtn.disabled = true;
    startSelect.disabled = true;
    endSelect.disabled = true;

    for(let i=0; i < steps.length; i++) {
      visualizeStep(steps[i]);
      highlightPath(path);
      await new Promise(r => setTimeout(r, 1500));
    }

    // Highlight final path on nodes and edges
    clearHighlights();
    path.forEach(id => {
      const nodeEl = svgNodes[id];
      if (nodeEl) {
        if (id === startSelect.value) nodeEl.classList.add('start');
        else if (id === endSelect.value) nodeEl.classList.add('end');
        else nodeEl.classList.add('highlighted');
      }
    });
    highlightPath(path);

    infoDiv.textContent =
      `Shortest path found!\nPath: ${path.join(' → ')}\nTotal distance: ${distance} meters`;

    startBtn.disabled = false;
    startSelect.disabled = false;
    endSelect.disabled = false;
  }

  // Event handlers
  startSelect.addEventListener('change', () => {
    updateButtonState();
    clearHighlights();
    infoDiv.textContent = 'Select start and destination, then click "Find Shortest Route"';
  });
  endSelect.addEventListener('change', () => {
    updateButtonState();
    clearHighlights();
    infoDiv.textContent = 'Select start and destination, then click "Find Shortest Route"';
  });

  startBtn.addEventListener('click', () => {
    clearHighlights();
    const start = startSelect.value;
    const end = endSelect.value;
    if (start === '' || end === '' || start === end) return;
    const { path, distance, steps } = runDijkstraGraph(start, end);
    if (distance === Infinity) {
      infoDiv.textContent = 'No path found between ' + start + ' and ' + end;
      return;
    }
    animateAlgorithm(steps, path, distance);
  });

  // Click on node sets start or end if not selected or cycles between them
  function nodeClickHandler(ev) {
    if (!startSelect.value) {
      startSelect.value = this.nodeId;
    } else if (!endSelect.value && this.nodeId !== startSelect.value) {
      endSelect.value = this.nodeId;
    } else if (this.nodeId === startSelect.value) {
      startSelect.value = '';
    } else if (this.nodeId === endSelect.value) {
      endSelect.value = '';
    }
    updateButtonState();
    clearHighlights();
    infoDiv.textContent = 'Select start and destination, then click "Find Shortest Route"';
  }

  function addNodeClickListeners() {
    Object.entries(svgNodes).forEach(([id, nodeEl]) => {
      nodeEl.nodeId = id;
      nodeEl.addEventListener('click', nodeClickHandler);
      nodeEl.addEventListener('keydown', e => {
        if(e.key === "Enter" || e.key === " ") {
          nodeClickHandler.call(nodeEl, e);
          e.preventDefault();
        }
      });
    });
  }

  // Initialize everything
  function init() {
    createSVGElements();
    populateSelects();
    updateButtonState();
    addNodeClickListeners();
  }
  init();

</script>
</body>
</html>

